<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Quadratic_Explorer</title>
<style>
body{margin:0;font-family:sans-serif;background:#f5f5f5}
.container{display:flex;height:100vh}
.left{width:50%;padding:20px;box-sizing:border-box;overflow-y:auto}
.right{width:50%;display:flex;justify-content:center;align-items:center;background:#eaeaea}
h1{font-size:20px}
.panel{background:white;padding:12px;border-radius:8px;margin-bottom:12px}
input[type="text"]{width:80px}
input[type="number"]{width:70px}
#explanation{background:#eef3ff;padding:10px;border-radius:6px}
canvas{background:white;border-radius:8px;cursor:grab;touch-action:none}
canvas:active{cursor:grabbing}
</style>
</head>

<body>
<div class="container">

<div class="left">
<h1>Quadratic Explorer</h1>

<div class="panel">
<b>① 文字 a の使い方</b><br>
<label><input type="checkbox" id="useCoef" checked> 係数に文字を使う</label>
<label><input type="checkbox" id="useInterval"> 区間に文字を使う</label>
</div>

<div class="panel">
<b>② 二次関数</b><br>
y =
<input id="coefA" value="1"> x² +
<input id="coefB" value="-2*a"> x +
<input id="coefC" value="1">
</div>

<div class="panel">
<b>③ 定義域</b><br>
<input id="L" value="-2"> ≤ x ≤
<input id="R" value="2">
</div>

<div class="panel">
<b>④ パラメータ a</b><br><br>
a の範囲：
<input type="number" id="aMin" value="-5"> ～
<input type="number" id="aMax" value="5"><br><br>
<input type="range" id="aSlider" min="-5" max="5" step="0.1" value="0">
<span id="aVal"></span>
</div>

<div class="panel">
<b>⑤ 表示操作</b><br>
・ドラッグ：移動<br>
・ホイール／ピンチ：拡大縮小<br>
<button onclick="resetView()">表示リセット</button>
</div>

<div id="explanation" class="panel"></div>
</div>

<div class="right">
<canvas id="canvas" width="600" height="450"></canvas>
</div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let view={xmin:-6,xmax:6,ymin:-10,ymax:10};
const PAD=40;

const cx=x=>PAD+(x-view.xmin)/(view.xmax-view.xmin)*(canvas.width-2*PAD);
const cy=y=>canvas.height-PAD-(y-view.ymin)/(view.ymax-view.ymin)*(canvas.height-2*PAD);

/* ===== 安全評価 ===== */
function safeEval(expr,a){
  if(!/^[0-9a-x+\-*/(). ]+$/.test(expr)) throw "invalid";
  return Function("a","return "+expr)(a);
}

/* ===== 描画 ===== */
function drawAxes(){
  ctx.strokeStyle="#aaa";
  ctx.beginPath();
  ctx.moveTo(cx(view.xmin),cy(0));
  ctx.lineTo(cx(view.xmax),cy(0));
  ctx.moveTo(cx(0),cy(view.ymin));
  ctx.lineTo(cx(0),cy(view.ymax));
  ctx.stroke();
}

function drawGraph(f,L,R){
  ctx.setLineDash([4,4]);
  ctx.strokeStyle="#999";
  ctx.beginPath();
  let first=true;
  for(let x=view.xmin;x<=view.xmax;x+=(view.xmax-view.xmin)/600){
    const y=f(x);
    if(first){ctx.moveTo(cx(x),cy(y));first=false;}
    else ctx.lineTo(cx(x),cy(y));
  }
  ctx.stroke();

  ctx.setLineDash([]);
  ctx.lineWidth=3;
  ctx.strokeStyle="#000";
  ctx.beginPath();
  first=true;
  for(let x=L;x<=R;x+=(R-L)/300){
    const y=f(x);
    if(first){ctx.moveTo(cx(x),cy(y));first=false;}
    else ctx.lineTo(cx(x),cy(y));
  }
  ctx.stroke();
  ctx.lineWidth=1;
}

function drawPoint(x,y,color){
  if(x<view.xmin||x>view.xmax||y<view.ymin||y>view.ymax) return;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(cx(x),cy(y),6,0,Math.PI*2);
  ctx.fill();
}

function drawVLine(x,color){
  if(x<view.xmin||x>view.xmax) return;
  ctx.setLineDash([5,5]);
  ctx.strokeStyle=color;
  ctx.beginPath();
  ctx.moveTo(cx(x),cy(view.ymin));
  ctx.lineTo(cx(x),cy(view.ymax));
  ctx.stroke();
  ctx.setLineDash([]);
}

/* ===== メイン ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawAxes();

  const a=+aSlider.value;
  aVal.textContent=a.toFixed(2);

  if(!useCoef.checked && /a/.test(coefA.value+coefB.value+coefC.value)){
    explanation.innerHTML="⚠ 係数に a は使えません";return;
  }
  if(!useInterval.checked && /a/.test(L.value+R.value)){
    explanation.innerHTML="⚠ 区間に a は使えません";return;
  }

  let A,B,C,left,right;
  try{
    A=safeEval(coefA.value,a);
    B=safeEval(coefB.value,a);
    C=safeEval(coefC.value,a);
    left=safeEval(L.value,a);
    right=safeEval(R.value,a);
  }catch{
    explanation.innerHTML="⚠ 式エラー";return;
  }

  if(A===0){explanation.innerHTML="⚠ 二次関数ではありません";return;}
  if(left>right)[left,right]=[right,left];

  const f=x=>A*x*x+B*x+C;
  const axis=-B/(2*A);

  drawGraph(f,left,right);
  drawVLine(axis,"#0078d7");
  drawVLine(left,"#00a000");
  drawVLine(right,"#00a000");

  let minX,maxX;
  if(axis>=left&&axis<=right){
    const far=Math.abs(left-axis)>Math.abs(right-axis)?left:right;
    if(A>0){minX=axis;maxX=far;}
    else{maxX=axis;minX=far;}
  }else{
    const yL=f(left),yR=f(right);
    if(yL<yR){minX=left;maxX=right;}
    else{minX=right;maxX=left;}
  }

  drawPoint(minX,f(minX),"blue");
  drawPoint(maxX,f(maxX),"red");

  explanation.innerHTML=
    `<b>結果</b><br>
     ${A>0?"上に開く":"下に開く"}放物線<br>
     軸：x=${axis.toFixed(2)}<br>
     最小値：f(${minX.toFixed(2)})=${f(minX).toFixed(2)}<br>
     最大値：f(${maxX.toFixed(2)})=${f(maxX).toFixed(2)}`;
}

/* ===== 移動・ズーム ===== */
let dragging=false,px,py;
canvas.addEventListener("mousedown",e=>{dragging=true;px=e.offsetX;py=e.offsetY});
canvas.addEventListener("mouseup",()=>dragging=false);
canvas.addEventListener("mouseleave",()=>dragging=false);
canvas.addEventListener("mousemove",e=>{
  if(!dragging)return;
  const dx=(e.offsetX-px)/canvas.width*(view.xmax-view.xmin);
  const dy=(e.offsetY-py)/canvas.height*(view.ymax-view.ymin);
  view.xmin-=dx;view.xmax-=dx;
  view.ymin+=dy;view.ymax+=dy;
  px=e.offsetX;py=e.offsetY;
  draw();
});

canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  zoomAt(e.offsetX,e.offsetY,e.deltaY>0?1.1:0.9);
});

function zoomAt(px,py,z){
  const mx=view.xmin+(px/canvas.width)*(view.xmax-view.xmin);
  const my=view.ymax-(py/canvas.height)*(view.ymax-view.ymin);
  view.xmin=mx+(view.xmin-mx)*z;
  view.xmax=mx+(view.xmax-mx)*z;
  view.ymin=my+(view.ymin-my)*z;
  view.ymax=my+(view.ymax-my)*z;
  draw();
}

function resetView(){
  view={xmin:-6,xmax:6,ymin:-10,ymax:10};
  draw();
}

/* ===== タッチ操作（スマホ・タブレット） ===== */
let touchDragging = false;
let prevDist = null;
let tx, ty;

canvas.addEventListener("touchstart", e => {
  e.preventDefault();

  if (e.touches.length === 1) {
    touchDragging = true;
    tx = e.touches[0].clientX;
    ty = e.touches[0].clientY;
  }

  if (e.touches.length === 2) {
    touchDragging = false;
    prevDist = getDist(e.touches);
  }
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();

  /* --- 1本指：移動 --- */
  if (touchDragging && e.touches.length === 1) {
    const nx = e.touches[0].clientX;
    const ny = e.touches[0].clientY;

    const dx = (nx - tx) / canvas.width * (view.xmax - view.xmin);
    const dy = (ny - ty) / canvas.height * (view.ymax - view.ymin);

    view.xmin -= dx;
    view.xmax -= dx;
    view.ymin += dy;
    view.ymax += dy;

    tx = nx;
    ty = ny;
    draw();
  }

  /* --- 2本指：ピンチズーム --- */
  if (e.touches.length === 2) {
    const dist = getDist(e.touches);
    const zoom = prevDist / dist;

    const mx =
      ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left);
    const my =
      ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top);

    zoomAt(mx, my, zoom);
    prevDist = dist;
  }
}, { passive: false });

canvas.addEventListener("touchend", () => {
  touchDragging = false;
  prevDist = null;
});

function getDist(t) {
  return Math.hypot(
    t[0].clientX - t[1].clientX,
    t[0].clientY - t[1].clientY
  );
}

/* ===== イベント ===== */
[aSlider,coefA,coefB,coefC,L,R,useCoef,useInterval]
.forEach(e=>e.addEventListener("input",draw));

[aMin,aMax].forEach(e=>e.addEventListener("input",()=>{
  aSlider.min=aMin.value;
  aSlider.max=aMax.value;
  aSlider.value=Math.min(Math.max(aSlider.value,aSlider.min),aSlider.max);
  draw();
}));

draw();
</script>
</body>
</html>

