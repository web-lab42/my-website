<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Quadratic_Explorer</title>
<style>
body {
  margin: 0;
  font-family: sans-serif;
  background: #f5f5f5;
}

.container {
  display: flex;
  height: 100vh;
}

.left {
  width: 50%;
  padding: 20px;
  box-sizing: border-box;
  overflow-y: auto;
}

.right {
  width: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #eaeaea;
}

h1 { font-size: 20px; }

.panel {
  background: white;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 12px;
}

input[type="text"] { width: 80px; }
input[type="number"] { width: 70px; }

#explanation {
  background: #eef3ff;
  padding: 10px;
  border-radius: 6px;
}

canvas {
  background: white;
  border-radius: 8px;
  cursor: grab;
  touch-action: none; /* ★ 超重要：ブラウザのスクロール抑止 */
}
canvas:active {
  cursor: grabbing;
}
</style>
</head>

<body>

<div class="container">

<div class="left">

<h1>Quadratic Explorer</h1>

<div class="panel">
<b>① 文字 a の使い方</b><br>
<label><input type="checkbox" id="useCoef" checked> 係数に文字を使う</label>
<label><input type="checkbox" id="useInterval"> 区間に文字を使う</label>
</div>

<div class="panel">
<b>② 二次関数</b><br>
y =
<input id="coefA" value="1"> x² +
<input id="coefB" value="-2*a"> x +
<input id="coefC" value="1">
</div>

<div class="panel">
<b>③ 定義域</b><br>
<input id="L" value="0"> ≤ x ≤
<input id="R" value="2">
</div>

<div class="panel">
<b>④ パラメータ a</b><br><br>
a の範囲：
<input type="number" id="aMin" value="-5"> ～ 
<input type="number" id="aMax" value="5"><br><br>
<input type="range" id="aSlider" min="-5" max="5" step="0.1" value="3.7">
<span id="aVal">3.7</span>
</div>

<div class="panel">
<b>⑤ 表示操作</b><br>
・ドラッグ：移動<br>
・ホイール／ピンチ：拡大縮小<br>
<button onclick="resetView()">表示リセット</button>
</div>

<div id="explanation" class="panel"></div>

</div>

<div class="right">
<canvas id="canvas" width="600" height="450"></canvas>
</div>

</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let view = { xmin:-6, xmax:6, ymin:-10, ymax:10 };
const PAD = 40;

/* ===== 座標変換 ===== */
const cx = x => PAD + (x-view.xmin)/(view.xmax-view.xmin)*(canvas.width-2*PAD);
const cy = y => canvas.height-PAD-(y-view.ymin)/(view.ymax-view.ymin)*(canvas.height-2*PAD);

/* ===== 軸 ===== */
function drawAxes(){
  ctx.strokeStyle="#aaa";
  ctx.beginPath();
  ctx.moveTo(cx(view.xmin),cy(0));
  ctx.lineTo(cx(view.xmax),cy(0));
  ctx.moveTo(cx(0),cy(view.ymin));
  ctx.lineTo(cx(0),cy(view.ymax));
  ctx.stroke();
}

/* ===== グラフ ===== */
function drawGraph(f,L,R){
  ctx.setLineDash([4,4]);
  ctx.strokeStyle="#999";
  ctx.beginPath();
  for(let x=view.xmin;x<=view.xmax;x+=(view.xmax-view.xmin)/600){
    const y=f(x);
    if(x===view.xmin) ctx.moveTo(cx(x),cy(y));
    else ctx.lineTo(cx(x),cy(y));
  }
  ctx.stroke();

  ctx.setLineDash([]);
  ctx.lineWidth=3;
  ctx.strokeStyle="#000";
  ctx.beginPath();
  for(let x=L;x<=R;x+=(view.xmax-view.xmin)/600){
    const y=f(x);
    if(x===L) ctx.moveTo(cx(x),cy(y));
    else ctx.lineTo(cx(x),cy(y));
  }
  ctx.stroke();
  ctx.lineWidth=1;
}

function drawPoint(x,y,color){
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(cx(x),cy(y),6,0,Math.PI*2);
  ctx.fill();
}

function drawVLine(x,color){
  ctx.setLineDash([5,5]);
  ctx.strokeStyle=color;
  ctx.beginPath();
  ctx.moveTo(cx(x),cy(view.ymin));
  ctx.lineTo(cx(x),cy(view.ymax));
  ctx.stroke();
  ctx.setLineDash([]);
}

/* ===== メイン描画 ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawAxes();

  const a=+aSlider.value;
  aVal.textContent=a.toFixed(2);

  if(!useCoef.checked && /a/.test(coefA.value+coefB.value+coefC.value)){
    explanation.innerHTML="⚠ 係数に a は使えません"; return;
  }
  if(!useInterval.checked && /a/.test(L.value+R.value)){
    explanation.innerHTML="⚠ 区間に a は使えません"; return;
  }

  let A,B,C,left,right;
  try{
    A=eval(coefA.value); B=eval(coefB.value); C=eval(coefC.value);
    left=eval(L.value); right=eval(R.value);
  }catch{
    explanation.innerHTML="⚠ 式エラー"; return;
  }

  if(A===0){ explanation.innerHTML="⚠ 二次関数ではありません"; return; }

  const f=x=>A*x*x+B*x+C;
  const axis=-B/(2*A);

  drawGraph(f,left,right);
  drawVLine(axis,"#0078d7");
  drawVLine(left,"#00a000");
  drawVLine(right,"#00a000");

  let minX,maxX;
  if(axis<left){minX=left;maxX=right;}
  else if(axis>right){minX=right;maxX=left;}
  else{
    minX=axis;
    maxX=Math.abs(left-axis)>Math.abs(right-axis)?left:right;
  }

  drawPoint(minX,f(minX),"blue");
  drawPoint(maxX,f(maxX),"red");

  explanation.innerHTML=
    `<b>解析結果</b><br>
     y = f(x)<br>
     軸：x = ${axis.toFixed(2)}<br>
     最小値：f(${minX.toFixed(2)})<br>
     最大値：f(${maxX.toFixed(2)})`;
}

/* ===== マウス操作 ===== */
let dragging=false, px,py;

canvas.addEventListener("mousedown",e=>{
  dragging=true; px=e.offsetX; py=e.offsetY;
});
canvas.addEventListener("mouseup",()=>dragging=false);
canvas.addEventListener("mouseleave",()=>dragging=false);

canvas.addEventListener("mousemove",e=>{
  if(!dragging) return;
  const dx=(e.offsetX-px)/canvas.width*(view.xmax-view.xmin);
  const dy=(e.offsetY-py)/canvas.height*(view.ymax-view.ymin);
  view.xmin-=dx; view.xmax-=dx;
  view.ymin+=dy; view.ymax+=dy;
  px=e.offsetX; py=e.offsetY;
  draw();
});

/* ===== ホイールズーム ===== */
canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  zoomAt(e.offsetX,e.offsetY,e.deltaY>0?1.1:0.9);
});

/* ===== タッチ操作（★追加） ===== */
let prevDist=null;

canvas.addEventListener("touchstart",e=>{
  if(e.touches.length===1){
    px=e.touches[0].clientX;
    py=e.touches[0].clientY;
  }
  if(e.touches.length===2){
    prevDist=getDist(e.touches);
  }
});

canvas.addEventListener("touchmove",e=>{
  e.preventDefault();

  if(e.touches.length===1){
    const dx=(e.touches[0].clientX-px)/canvas.width*(view.xmax-view.xmin);
    const dy=(e.touches[0].clientY-py)/canvas.height*(view.ymax-view.ymin);
    view.xmin-=dx; view.xmax-=dx;
    view.ymin+=dy; view.ymax+=dy;
    px=e.touches[0].clientX;
    py=e.touches[0].clientY;
    draw();
  }

  if(e.touches.length===2){
    const dist=getDist(e.touches);
    const zoom=prevDist/dist;
    const rect=canvas.getBoundingClientRect();
    const mx=((e.touches[0].clientX+e.touches[1].clientX)/2-rect.left);
    const my=((e.touches[0].clientY+e.touches[1].clientY)/2-rect.top);
    zoomAt(mx,my,zoom);
    prevDist=dist;
  }
});

canvas.addEventListener("touchend",()=>prevDist=null);

function getDist(t){
  return Math.hypot(
    t[0].clientX-t[1].clientX,
    t[0].clientY-t[1].clientY
  );
}

function zoomAt(px,py,zoom){
  const mx=view.xmin+(px/canvas.width)*(view.xmax-view.xmin);
  const my=view.ymax-(py/canvas.height)*(view.ymax-view.ymin);
  view.xmin=mx+(view.xmin-mx)*zoom;
  view.xmax=mx+(view.xmax-mx)*zoom;
  view.ymin=my+(view.ymin-my)*zoom;
  view.ymax=my+(view.ymax-my)*zoom;
  draw();
}

/* ===== その他 ===== */
function updateARange(){
  aSlider.min=aMin.value;
  aSlider.max=aMax.value;
  draw();
}
function resetView(){
  view={xmin:-6,xmax:6,ymin:-10,ymax:10};
  draw();
}

[aSlider,coefA,coefB,coefC,L,R,useCoef,useInterval]
  .forEach(e=>e.addEventListener("input",draw));
[aMin,aMax].forEach(e=>e.addEventListener("input",updateARange));

draw();
</script>

</body>
</html>

